import itertools as it
import math
import numpy as np

FR_CASES = [[2, 2, 2, 1], [2, 2, 1, 1], [2, 2, 1, 0]]

# sum_{i=1}^{4}(i + 1) = 14
NUM_COVERED_SETS = 14
FIXED_ROOK_SCENARIOS = 3
NUM_PIECE_TYPES_LESS_KING = 4
MAX_OF_ANY_ONE_BASE_PIECE = 2

# (2, 2, 1, 0) gives rise to permutation with greatest cost: (1, 0, 2, 2)
# which is base cost + 3. There are also base + 1, base + 2, ... so 4 in total
MAX_ADDITIONAL_COST_ABOVE_BASE_COST = 3

INDICES_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
)
PERMS_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    NUM_COVERED_SETS,
    math.factorial(NUM_PIECE_TYPES_LESS_KING),
    NUM_PIECE_TYPES_LESS_KING,
)
COST_BOUNDARIES_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    NUM_COVERED_SETS,
    MAX_ADDITIONAL_COST_ABOVE_BASE_COST + 1,
)

fr_coveredSet_indices = np.negative(np.ones(INDICES_SHAPE, np.int32))
fr_coveredSet_perms = np.negative(np.ones(PERMS_SHAPE, np.int32))
fr_coveredSet_perm_cost_boundaries = np.negative(np.ones(COST_BOUNDARIES_SHAPE, np.int32))


def covered_sets(fr_case_num):
    b = FR_CASES[fr_case_num]
    s = b.copy()
    fr_coveredSet_indices[fr_case_num][s[0]][s[1]][s[2]][s[3]] = 0
    yield s, 0

    cset_num = 1
    while s[0] != 0:
        for i in range(NUM_PIECE_TYPES_LESS_KING - 1, -1, -1):
            if s[i] != 0:
                s[i] -= 1
                for j in range(i + 1, NUM_PIECE_TYPES_LESS_KING):
                    s[j] = min(s[i], b[j])

                fr_coveredSet_indices[fr_case_num][s[0]][s[1]][s[2]][s[3]] = cset_num
                yield s, cset_num

                cset_num += 1
                break


def cost(s, b):
    c = 0
    for i in range(NUM_PIECE_TYPES_LESS_KING):
        d = s[i] - b[i]
        if d > 0:
            c += d
    return c


def c_arr_literal_str_helper(a, d):
    s = "{"
    if len(a.shape) == 1:
        for i in range(a.shape[0] - 1):
            s += str(a[i]) + ", "
        s += str(a[a.shape[0] - 1])
    else:
        for i in range(a.shape[0]):
            s += c_arr_literal_str_helper(a[i], d + 1)
    s += "}"
    if d != 0:
        s += ", "
    return s


def c_arr_literal_str(a):
    return c_arr_literal_str_helper(a, 0)


def c_dimensions_str(shape):
    s = ""
    for dim in shape:
        s += "[" + str(dim) + "]"
    return s


def format_c_arr_str(a, npname):
    s = "char "
    s += npname
    s += c_dimensions_str(np.shape(a))
    s += " = "
    s += c_arr_literal_str(a)
    s += ";"
    return s


for i in range(FIXED_ROOK_SCENARIOS):
    for (s, cset_num) in covered_sets(i):
        cost_to_perms = {}
        for p in it.permutations(s):
            c = cost(p, FR_CASES[i])
            if c not in cost_to_perms:
                cost_to_perms[c] = []
            else:
                cost_to_perms[c].append(tuple(p))

        pi = 0
        for c, perms in sorted(cost_to_perms.items()):
            for e in perms:
                for j in range(NUM_PIECE_TYPES_LESS_KING):
                    fr_coveredSet_perms[i][cset_num][pi][j] = e[j]
                pi += 1

            fr_coveredSet_perm_cost_boundaries[i][cset_num][c] = pi

for i in range(fr_coveredSet_perm_cost_boundaries.shape[0]):
    for j in range(fr_coveredSet_perm_cost_boundaries.shape[1]):
        v =  fr_coveredSet_perm_cost_boundaries[i][j][0]
        for k in range(1, fr_coveredSet_perm_cost_boundaries.shape[2]):
            if fr_coveredSet_perm_cost_boundaries[i][j][k] == -1:
                fr_coveredSet_perm_cost_boundaries[i][j][k] = v
            else:
                v = fr_coveredSet_perm_cost_boundaries[i][j][k]

f = open("piece_permutations.c", "w")
f.write("// Generated by gen_prom_perms.py.\n")
f.write("// Formatted by clang thereafter\n\n")
f.write("#include \"tree_common.h\"\n\n")
f.write(format_c_arr_str(fr_coveredSet_indices, "fr_coveredSet_indices"))
f.write("\n")
f.write(format_c_arr_str(fr_coveredSet_perms, "fr_coveredSet_perms"))
f.write("\n")
f.write(format_c_arr_str(fr_coveredSet_perm_cost_boundaries, "fr_coveredSet_perm_cost_boundaries"))
